stages:
  - version
  - build
  - publish

variables:
  DOCKER_IMAGE_NAME: $CI_REGISTRY_IMAGE
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# Only run on tags that match semantic versioning pattern
.tag_rules: &tag_rules
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/

# Extract version from tag (remove 'v' prefix)
.extract_version: &extract_version
  - export VERSION=${CI_COMMIT_TAG#v}
  - echo "Building version $VERSION"

# Update version in source code
update_version:
  stage: version
  image: alpine:latest
  <<: *tag_rules
  before_script:
    - apk add --no-cache sed
    - *extract_version
  script:
    # Update version in pyproject.toml
    - sed -i "s/^version = .*/version = \"$VERSION\"/" pyproject.toml
    # Update version in setup.py
    - sed -i "s/version=\"[^\"]*\"/version=\"$VERSION\"/" setup.py
    # Update version in __init__.py
    - sed -i "s/__version__ = .*/__version__ = \"$VERSION\"/" src/trackmaster/__init__.py
    # Update version in API response
    - sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" src/trackmaster/api.py
  artifacts:
    paths:
      - pyproject.toml
      - setup.py
      - src/trackmaster/__init__.py
      - src/trackmaster/api.py
    expire_in: 1 hour

# Build Docker image
build_docker:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  <<: *tag_rules
  dependencies:
    - update_version
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - *extract_version
  script:
    # Build the Docker image with version tags
    - docker build 
        --build-arg VERSION=$VERSION 
        --tag $DOCKER_IMAGE_NAME:$VERSION 
        --tag $DOCKER_IMAGE_NAME:latest 
        .
    # Test the built image
    - docker run --rm --detach --name trackmaster-test -p 8000:8000 $DOCKER_IMAGE_NAME:$VERSION
    - sleep 10
    - docker exec trackmaster-test curl -f http://localhost:8000/health || exit 1
    - docker stop trackmaster-test
  artifacts:
    reports:
      dotenv: build.env

# Publish to GitLab Container Registry
publish_docker:
  stage: publish
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  <<: *tag_rules
  dependencies:
    - build_docker
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - *extract_version
  script:
    # Push both version tag and latest
    - docker push $DOCKER_IMAGE_NAME:$VERSION
    - docker push $DOCKER_IMAGE_NAME:latest
    # Create and push additional tags
    - |
      if [[ $VERSION =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
        MAJOR=${BASH_REMATCH[1]}
        MINOR=${BASH_REMATCH[2]}
        
        # Tag with major version (e.g., v1)
        docker tag $DOCKER_IMAGE_NAME:$VERSION $DOCKER_IMAGE_NAME:v$MAJOR
        docker push $DOCKER_IMAGE_NAME:v$MAJOR
        
        # Tag with major.minor version (e.g., v1.1)
        docker tag $DOCKER_IMAGE_NAME:$VERSION $DOCKER_IMAGE_NAME:v$MAJOR.$MINOR
        docker push $DOCKER_IMAGE_NAME:v$MAJOR.$MINOR
      fi
  after_script:
    - echo "Docker images published:"
    - echo "  $DOCKER_IMAGE_NAME:$VERSION"
    - echo "  $DOCKER_IMAGE_NAME:latest"
    - echo "  $DOCKER_IMAGE_NAME:v${VERSION%%.*}"
    - echo "  $DOCKER_IMAGE_NAME:v${VERSION%.*}"

# Optional: Create GitLab release
create_release:
  stage: publish
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  <<: *tag_rules
  dependencies:
    - publish_docker
  before_script:
    - *extract_version
  script:
    - |
      release-cli create \
        --name "TrackMaster v$VERSION" \
        --description "TrackMaster AI Audio Mastering Server v$VERSION

        ## Docker Images
        - \`$DOCKER_IMAGE_NAME:$VERSION\`
        - \`$DOCKER_IMAGE_NAME:latest\`
        
        ## Usage
        \`\`\`bash
        docker run -p 8000:8000 $DOCKER_IMAGE_NAME:$VERSION
        \`\`\`
        
        ## API Documentation
        Available at http://localhost:8000/docs after starting the container.
        " \
        --tag-name $CI_COMMIT_TAG \
        --ref $CI_COMMIT_SHA
